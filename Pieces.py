from Utils import _catchOutofBounce, _positivePos

_directions = {
    "up": ((-1,0), (-1,1), (-1,-1)),
    "down": ((1,0), (1,1), (1,-1)), 
    "right": ((0,-1), (1,-1), (-1,-1)),
    "left": ((0,1), (1,1), (-1,1))
}

class Piece():
    def __init__(self, color, value, symbol):
        self._position = None
        self.color = color
        self.value = value
        self.symbol = symbol
        self.firstMove = True


    def __str__(self):
        return self.symbol


    @property
    def position(self):
        return self._position


    @position.setter
    def position(self, pos):
        self._position = pos


    def move(pos):
        self.position = pos
        self.firstMove = False
    

    def getDest(self, off_x, off_y):
        return (self._position[0] + off_x, self._position[1] + off_y)


    @_positivePos
    @_catchOutofBounce
    def canWalk(self, pos, board):
        return board.isEmpty(pos)


    @_positivePos
    @_catchOutofBounce
    def canCapture(self, pos, board):
        destPiece = board[pos]
        try:
            return destPiece.color != self.color
        except AttributeError:
            return False


    @_positivePos
    @_catchOutofBounce
    def canMove(self, pos, board):
        destPiece = board[pos]
        try:
            return destPiece.color != self.color
        except AttributeError:
            return True


    def getMovesInLine(self, iterFunc, board, off_x0=0, off_y0=0):

        moveList = []
        off_x, off_y = iterFunc(off_x0, off_y0)
        dest = self.getDest(off_x, off_y)

        while self.canWalk(dest, board):
            moveList.append(dest)
            off_x, off_y = iterFunc(off_x, off_y)
            dest = self.getDest(off_x, off_y)

        if self.canCapture(dest, board):
            moveList.append(dest)

        return moveList


class Pawn(Piece):
    def __init__(self, color, direction="up"):
        super().__init__(color, 1, "P")

        direction = direction.lower()
        if direction in _directions.keys():
            self.direction, self.diagonal_1, self.diagonal_2 = _directions[direction]
        else:
            raise ValueError("Given direction is not any of \"up\", \"down\", \"left\" or \"right\".")


    def getMoves(self, board):
        """
        Returns list of possible destinations
        """

        destList = []

        dest = self.getDest(*self.direction)
        if self.canWalk(dest, board):
            destList.append(dest)

            if self.firstMove:
                dest = self.getDest(*(self.direction[0]*2, self.direction[1]*2))
                if self.canWalk(dest, board):
                    destList.append(dest)

        dest = self.getDest(*self.diagonal_1)
        if self.canCapture(dest, board):
            destList.append(dest)

        dest = self.getDest(*self.diagonal_2)
        if self.canCapture(dest, board):
            destList.append(dest)

        return destList


class Rook(Piece):
    def __init__(self, color):
        super().__init__(color, 5, "R")


    def getMoves(self, board):
        """
        Returns list of possible destinations
        """

        destList = []
        
        destList.extend(self.getMovesInLine(lambda i, j : (i+1, j), board))

        destList.extend(self.getMovesInLine(lambda i, j : (i, j+1), board))

        destList.extend(self.getMovesInLine(lambda i, j : (i-1, j), board))

        destList.extend(self.getMovesInLine(lambda i, j : (i, j-1), board))
        
        return destList


class Knight(Piece):
    def __init__(self, color):
        super().__init__(color, 3, "N")


    def getMoves(self, board):
        """
        Returns list of possible destinations
        """

        destList = []

        # As with the king these offsets can be generated by an algorithm but
        # I figured this is more readable even though it requires additional memory
        offsetList = [
        (1,2),
        (1,-2),
        (-1,2),
        (-1,-2),
        (2,1),
        (2,-1),
        (-2,1),
        (-2,-1)]

        for offset in offsetList:
            
            dest = self.getDest(*offset)
            if self.canMove(dest, board):
                destList.append(dest)

        return destList


class Bishop(Piece):
    def __init__(self, color):
        super().__init__(color, 3, "B")


    def getMoves(self, board):
        """
        Returns list of possible destinations
        """

        destList = []

        destList.extend(self.getMovesInLine(lambda i, j : (i+1, j+1), board))

        destList.extend(self.getMovesInLine(lambda i, j : (i-1, j-1), board))

        destList.extend(self.getMovesInLine(lambda i, j : (i-1, j+1), board))

        destList.extend(self.getMovesInLine(lambda i, j : (i+1, j-1), board))

        return destList


class King(Piece):
    def __init__(self, color):
        super().__init__(color, int(1e10), "K")


    def getMoves(self, board):
        """
        Returns list of possible destinations
        """

        destList = []

        # As with the knight these offsets can be generated by an algorithm but
        # I figured this is more readable even though it requires additional memory
        offsetList = [
        (1,0),
        (1,1),
        (0,1),
        (-1,1),
        (-1,0),
        (-1,-1),
        (0,-1),
        (1,-1)]

        for offset in offsetList:

            dest = self.getDest(*offset)
            if self.canMove(dest, board):
                destList.append(dest)

        return destList


class Queen(Piece):
    def __init__(self, color):
        super().__init__(color, 9, "Q")


    def getMoves(self, board):
        """
        Returns list of possible destinations
        """

        destList = []

        destList.extend(self.getMovesInLine(lambda i, j : (i+1, j), board))

        destList.extend(self.getMovesInLine(lambda i, j : (i, j+1), board))

        destList.extend(self.getMovesInLine(lambda i, j : (i-1, j), board))

        destList.extend(self.getMovesInLine(lambda i, j : (i, j-1), board))

        destList.extend(self.getMovesInLine(lambda i, j : (i+1, j+1), board))

        destList.extend(self.getMovesInLine(lambda i, j : (i-1, j-1), board))

        destList.extend(self.getMovesInLine(lambda i, j : (i-1, j+1), board))

        destList.extend(self.getMovesInLine(lambda i, j : (i+1, j-1), board))

        return destList


class _Disabled():
    symbol = " "


class _Empty():
    symbol = "0"